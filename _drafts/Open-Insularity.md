---
title: Open Insularity
description:
tags:
- Free Software
- Ideology
- Open Source
- Politics
---

I grew up on narratives and ideologies of free and open source software.  They shaped my thinking in ways I'll probably never be able to fully appreciate.  But the more experience I gain with the impact of those ideas in practice, the more the terms "free" and "open" cut with deep, painful irony.

Our source may be open, as we define open.  Our software may be free, as we define free.  But as an industry, as a culture, and as individual people we are, as a whole, profoundly closed.  Content to inhabit a narrow world of our own construction, "freedom" and "openness" don't change our minds.  They justify our closed-mindedness.

Those justifications for what we wanted to begin with---to play with computers unimpeded---worked a treat.  For a while.  But these days, from any outside point of view, they're an obvious prescription for insularity bordering on conspiracy. People who aren't computer people now have every opportunity to see the results, and cry foul.

It's time for a hard, honest look from the outside.

## Itches

Our "open" culture celebrates scratching our own itches.  A truly open culture would celebrate scratching _others'_ itches, the further from our own, the better.

Writing software for ourselves and others like us bypasses all the hardest parts of making software.  That can and does produce some good results.  But a terrible price: reinforcing our personal isolation and the insularity of programming overall.  For us, by us, all amongst ourselves.

Developing developer tools for fellow developers makes a pretty nice toolkit, or at least a large and very full one.  But it flexes none of the necessary muscles for understanding people, writing the software they need, confirming their needs have been well and truly met, and staying abreast of those needs as they change over time.

Eliciting requirements and feedback isn't necessary when all the requirements and feedback are our own.  Accountability happens all in one head.  So our communication atrophies to the acerbic, confrontational engineering tone we're infamous for.  Which keeps us talking to ourselves.

Ensuring our work actually satisfies a need happens inevitably when we satisfy our own.  So a thousand web frameworks bloomed while encryption, automated version control, and other basics remained impractical for the average Jane or Joe.

Learning and leveraging new platforms, venues, and communication styles doesn't happen when we pick our platforms, venues, and communication styles of choice over and over again.  GitHub hasn't taken off as a general-purpose collaboration tool outside software.  The more software-specific features it piles on, the harder it becomes to get any other kind of people to come over and play.

Access to programming at an early age, and therefore programming addiction, correlates tightly with specific social and demographic factors.  So communing with fellow programming addicts usually means communing with others very similar to ourselves more broadly.  The result is a community riding the edge of monoculture.  Monocultures are often productive ... until they're utterly compromised.

Non-programmers didn't do this to programmers.  Non-programmers clamor for programmer help.  We did this to ourselves, while issuing many self-congratulations for pioneering "openness" and establishing a model for the rest of the known universe.

## Egos

Our "open" culture provides home-grown frameworks---self-styled "philosophies" and "ethics"---to stroke our own egos.

A truly open culture hold itself accountable to the broadest, best-developed moral and political theories available.

I accepted delusions of ethical grandeur and loose use of weighty words like "philosophy" because they imbued my personal choices about software, well within my control, even in childhood, with outsize meaning and importance.  They enabled me to believe that my use of a copyright license, or even my taste in other peoples' software, amounted to countercultural, charitable, even revolutionary acts.

They did not.  Except in the eyes of the similarly seduced.

A glancing comparison to nearly any other source of moral teaching available would have revealed how simplistic that line of thinking was.  Moral philosophy remains messy, frustrating, and humbling, like engineering, medicine, social work, and any other discipline accountable to the muck and mire of reality.  Moral codes come riddled with exceptions, littered with factors to weigh and balance.  Hacker ideologies ask little, deliver clarity, feel great, and promise empowerment.

Too good to be true is easy to spot, unless it's too good for _you_.  Software freedom was very good to me.  It _felt_ better, even though it was worse.  But I wasn't accountable to anyone, except to myself, so my feelings won out over any kind of consistency.  Until the reality checks.  Lots of them.  Over decades.

Enabling facts are welcome.  Inconvenient facts are not.  When software-freedom absolutism indirectly facilitates a good outcome in any other dimension, the true believer happily credits the cause.  Given absolute freedom, they tell us to expect all good to follow.  But when software freedom takes a toll, the faithful blame the victim.  You shouldn't have made it open source ... like I told you to.  You didn't do it open enough ... my way.  You didn't do it for the right reasons ... my reasons.  You didn't use the right tools ... my tools.  The more enlightened, who speak from one side of their mouths, write off as collateral damage.

At one point or another, I've brandished all these too-handy weapons.  I was reassuring myself more than criticizing the other, but still very much at the other's expense.

Just as computer programming reduces complex problems down to computable approximations, ethical and political conversations trapped within software, which only step outside to grab glittering generalities like "freedom" and "community", derive a neatly computable program for a bad approximation of life.  Just as software reductionism looses well-intentioned, malign systems on the world, reductionism makes wanton, antisocial automata of otherwise capable consciences, blinkered or indifferent to predictable consequences.  When good theory starts from bad assumptions, applying that theory to the world, or force-fitting the world to suit, makes causalities.

Trading completeness and gritty realism for expedience and clean clarity often means trading hard decisions and balanced outcomes for easy decisions and predictable carnage.  "It depends" is often correct, but never pleasant to hear.  But the comfort of pop theory, of easy certainty, so easily becomes the surest sign of truth, and therefore virtue.  Programmers pare rightness down to Turing-esque, deductive, boolean reasoning---freedom or no freedom---because left to ourselves, we select for the story that pleases us most, not those on the receiving end, who we've thoroughly abstracted away.

Until you cross the line from open source taker to open source maker.  Until you realize you'll be subject to the decisions of others more often than they'll be subject to yours.  Until you face your dependence and your interdependence, master of machine though you may be.

## Justifications

Our "open" culture provides the justifications to enable our own addictions to interactive computing.

A truly open culture would invite outside accountability.

## Defenses

Our "open" culture normalizes rejection of all outside criticism of our values, frameworks, justifications, and choices.

A truly open culture would welcome critique _especially_ from those of different perspectives, especially when they take the time to offer help outside their own comfort zones.

## Others

Our "open" culture validates our self-aggrandizing belief that hacker supremacy is inevitable, that in the long run, everyone will be a hacker.

A truly open culture would leave as much room as possible for other skills, callings, and fascinations, seeking to serve as many as possible while asking as little tribute in return.

## Childhood

Our "open" culture infantilizes us, elevating conditions peculiar to early life to the noblest ideal.

A truly open culture would 

## Usability

<!-- start from what we want, but make concession to smoothing it over for others -->

<!-- In an ideal world, as few people have to be programmers as possible. -->

## (Scraps)

The mythologized "hacker ethic" of open source software trumpets freedom and autonomy.  Computers should be free.  Information should be free.  Authority shouldn't exist.  We should judge each other and ourselves by what we can do with computers and information, free of authority, and marvel in the beautiful, life-changing results.

Taken to extremes, freedom and autonomy become arrogance and isolation.  The hacker ethic demonstrates arrogance and isolation as well as freedom and autonomy. The tenets of hacking make it insular, parochial, preachy, and alone.  They celebrate a lifestyle where hacking is life and life is reduced to hacking.  They invite us to separate computing from the rest of the world, to make computing its own world, and to pretend that is or should be enough for human beings.

It can be enough, so long as all you want to do is hack, and your only obstacles are people, systems, or licenses that say "no" to your hacking.  That's typical of childhood, even early adulthood, experience.  When childhood has come and gone, the convenient scapegoats of parental and school authority give way to existential angst, the revolutionary benefits of churning out code fail to materialize, and exposure, even incidental exposure, to different experiences, cultures, and concerns .