---
title: The Tyranny of Time
description: licensing as ...
layout: post
tags:
- Open Source
- Licensing
brief: Treating licensing as taboo holds developers back.
---

If you polled open software pundits, I think prevailing sentiment would say:  Hiring good.  Licensing bad.

I don't get it.  And I don't like the consequences.

In the end, software is useful, people will pay for it, and it takes time to make.  The _structure_ of a producer-consumer relationship---employment, contract, or license---doesn't determine value, but merely reflects it.  Different structures afford flexibility to reorder development, payment, and permission in time.  Writing one approach---licensing---off as evil surrenders most of that flexibility.

It gets worse when we see how different structures play out in practice.  Tradition and inertia constrain employment, contracting, and licensing.  Norms are deeply ingrained, and long predate the software industry.  The norms for employment and contracting hold many developers back late in their careers.  Promoting pay for time, and deprecating pay for permission, encourages developers to sell themselves short, to keep punching the clock for others when they could be making entrepreneurial bets for themselves, or to flee programming entirely.

Let's break it down through a story.  We'll play it as theme and variations.

## First

I'm a CEO.  I meet Bob at a conference.  We talk about my industry.

A week later, I contract Bob to write some software.  He spends ten hours and bills $3,000.  Everything goes well.  Bob's code works great.

Rewind.

## Second

Bob and I have never met, but Bob has read a few blogs about my industry.  Because of his reading, Bob decides some new software needs to exist in the universe.  He writes the software.  Bob's code works great.

_Then_ I show up.  We meet at a conference.  We talk about my industry.

A week later, I reach out to Bob for some software.  He's already written it.  He sends me a link to the GitHub repo.  It's all there, except for `LICENSE`.  So I pay Bob for a license.

I get the software I need.  Bob gets the money he needs.  And it's a good thing he does, because between conference and sale, Bob's partner's cancer comes back.

Now Bob is a full-time caregiver.  No more programming for Bob.  If he hadn't written the software before, he couldn't write it now.  And I'd be out of luck.

Rewind again.

## Third

Bob writes the software.  We meet at the conference.  Bob links me to the repo.  It's all there, with MIT pasted into `LICENSE`, because GitHub told Bob to choose a license.

Bob's code works great.  I reach out to him two weeks later, about new features, support, and training.  But I can't hire Bob.  Bob's partner's cancer came back, and Bob's a full-time caregiver now.  No money for Bob.  No features, support, or training for me.

## Time

One programmer.  One piece of software.  Three different stories.  Three very different outcomes.

In each story, Bob spent a ton of time becoming a programmer and enough time learning about my industry to meet my business needs.  All of that time and effort made Bob capable of spending the time he needed to write the software that I needed.

But in no story did I really pay Bob for time.  Multiplying time spent by a cost per hour was just a convenient way to decide how much I'd pay.  I really paid for the value of the software Bob could make, whether he'd already made it or was available to make it.

Say Bob's hourly rate were $300.  If Bob spent ten hours creating new software for me, the cost of that software would be $3,000.

If Bob had set his rate too low by half instead, but delivered software that didn't meet my needs, I'd pay Bob far less, and likely resent him.  I'd've wasted $1,500, plus all the time meeting, hiring, and paying Bob for nothing useful.

Conversely, if Bob had set his rate twice as high, and spent twice as much time, but his software saved me three times its cost, I'd sing Bob's praises.  Bob just helped me make $24,000.

I don't care how much time Bob takes to make the software.  Unless the time Bob takes determines whether I can get my hands on the software in time to meet my needs, in which case I'd prefer above all to learn that he's already written it.  Or unless I sign a contract with Bob that says how much time he takes determines how much I'll pay.

## Structure

If I hire Bob to spend the time making new software, he takes less risk than if he spends the time first, and hopes someone will show up to buy a license later.  On contract, or as an employee, Bob knows that he has at least one paying customer, if only one paying customer.  Without a contract, Bob hopes he'll find one.  One at least.

I have competitors.  Naturally.  Those competitors could sure use Bob's software, too.  Naturally.

If I hire Bob under standard employee or contractor terms, I own the software Bob makes.  Bob can't sell it to my competitors, or even tell them it exists.  The software is _mine_, not Bob's, because the terms I signed with Bob say so.

Hopefully Bob priced accordingly.  But that will be hard for Bob.  I probably know a lot more about my industry and my competitors---Bob's potential market---than Bob does.  I might even insist on owning Bob's software so that _I_ can turn around and sell licenses to others, without sharing the earnings with Bob.

Maybe Bob could have charged me $30,000 instead of $3,000.  Maybe it's actually worth $100,000 to my business.  But here's the catch: $3,000 per hour is an exorbitant hourly rate!

Why?  Is there a glut of available programming talent, similarly read up on my industry and interested in solving the problem?  Are they easy to find, and available to hire?  Why should they do the work for less, if the value to my business remains the same?  Do we assume developers ought to be grateful for whatever work they can get?

Pretending that I pay for Bob's time, rather than Bob's software, distracts from the question of value.  As any business hires an employee in anticipation of making more on their work than it pays them in salary and benefits, I can hire Bob in anticipation of making more from his software than I pay for his time.  And it behooves me to change the game from identifying a license price based on the value to my business, which puts me in an awkward bargaining position, to justifying Bob's compensation against that of other programmers, which puts Bob in an awkward bargaining position.

## Restructure

That's employee-contractor normal.  Contrast licensing.

If I pay Bob for a license under typical license terms, Bob stills owns his software, and can sell licenses to others.  If he finds out about my competitors, or they find out about him, he might make far more, selling more licenses.

That's true even if Bob's partner's cancer comes back, and he can't make software or deals full-time.  Perhaps Bob sets up a web store, and sells licenses that way.  Perhaps Bob sells subscription-style license agreements that require customer to pay each month or each year, whether he sends updates or not.  Perhaps Bob hires an agent, or finds a partner, who sells licenses for him, and takes commission.

If Bob can't work, eventually his software will lose value.  Bob won't be able to fix bugs, add new features, update for changes in other software, or provide related services like integration, training, or support.  But if Bob makes money from licensing software he's already written, he might be able hire others to do what he can't, going forward.  For example, he might hire another developer to maintain his work, and keep it relevant, so that new customers continue buying licenses.

A license _could_ produce much the same result as a typical employment or contracting relationship.  Bob could license his software to me exclusively, meaning he can't license it to anyone else.  Bob could license his software to me with rights to resell without royalty, allowing me to tell Bob's software to others without paying anything to Bob.  I could agree to pay a one-time license fee based on Bob's report of how much time he spent creating the software.  But all of those terms are unusual for licenses, while they're definitional for employees and contractors.

## Footing

Licensing gives creators flexibility in time.  It transforms their financial relationships with users from exchanges of money for work time into exchanges of money for work product.  It gives creators a means of earning---license fees, also called royalties---that naturally reflects the value of their work, and the number of others for whom its valuable, rather than some approximation of time put into it.

As a result, licensing lets programmers invest their time, rather than simply sell it.  The value they build up in accumulated, licensable software pays like stock in a company, ownership of a rental property, or accumulated reputation, rather than a paycheck.  That decoupling of time spent and earnings received puts a developer in the position of an entrepreneur, rather than a human resource.  It ruptures standard workaday incentives to spend more time than necessary, and to deliver no more than necessary, by shifting the economic focus onto the value of the software.

There is no reason this couldn't happen in the structure of a contracting or employment arrangement.  Some well established developers _do_ make large multiples of typical hourly work rates, earn substantial incentive, bonus, or commission payments, command grants of company stock or other securities with exposure to greater risk and reward, and even retain options or other interests in the work they create.

If licensing is effectively discouraged, and norms of employment and contracting hold strong, the accomplished programmer is naturally drawn to found a company.  Becoming a manager, rather than a full-time developer, enables the erstwhile developer to cross the worker-investor divide.  It enables them to invest, to speculate, like an entrepreneur ... by paying for services of others on a time basis.

This happens frequently.  We see it a lot.  But that does not end the story.

The programmer who becomes an entrepreneur usually stops programming.  That is just one symptom of the high costs of company startup and operation.  Those costs prevent many who would start companies from doing so.  At a minimum, the transition is artificially delayed: programmers have to earn and save enough by selling their time, or finding other ways to invest, to afford the sunk cost of standing up a business.